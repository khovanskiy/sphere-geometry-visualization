Geometry
========

Следует учесть, что инструкция написана исходя из того, что перед установкой была уже выполнена инструкция Ковалева и все зависимости сохранились. Также я надеюсь, что будет использоваться QtCreator >= 5.0 && (Ubuntu >=12.0 || Windows >= 7). Иначе, если хотя один из пунктов не выполнен, то за работоспособность кода я не отвечаю :) 

В общем случае нужно:
```sudo apt-get install qtcreator git cmake-curses-gui libgmp-dev libqt4-dev libboost1.54-all-dev subversion```

## Controls

**W, UP** - decrease colatitude

**S, DOWN** - increase colatitude


**A, LEFT** - decrease azimuth

**D, RIGHT** - increase azimuth


**-, +, Mouse wheel** - zoom in/out

**V**- put 1 point at current coordinateses

**X** - delete 1 point from current coordinateses

**R** - reset

## Getting Started
1. Скачиваем проект целиком ```git clone git://github.com/khovanskiy/geometry.git```
2. Создаем класс и наследуем его от класса Visualization c public видимостью.
3. Для добавления точки пишем: ```addPoint(Vector2D(x1, y1));```
4. Для добавления полилинии пишем: ```addLine(Vector2D(x1, y1), Vector2D(x2, y2));```

**Важно:** Vector2D - обычный 2-d вектор, и очевидно, что долгота и широта != x и y. Поэтому условно считается, что координаты задаются в формате Vector2D my_vector(colatitude, azimuth).

**colatitude** - зенитный угол (угол между осью Z и радиус-вектором, направленным к данной точке на сфере).

**azimuth** - азимутный угол (угол между осью X и радиус-вектором, направленным к данной точке на сфере).

3D-пространство, на которое проецируется сфера, задано правой тройкой базисных векторов с осью Z, направленной вверх.
Условно оси имеют цвета:

1. X - красный
2. Y - зеленый
3. Z - синий

Почему так? А потому что эти условные обозначения используются успешно много лет в различных 3D-редакторах. Хотете поменять? - Редактируйте класс AxisView.

## Примеры использования
Изменение радиуса сферы на 200rem
```
setRadius(200);
```

Получение текущего радиуса сферы
```
double current_radius = getRadius();
```

Устанавливаем количество сегментнов линии равным 20
```
setLineSegments(20);
```

Устанавливаем количество сегментнов сферы равным 35
```
setSpaceSegments(35);
```

Добавляем на сферу сферический прямоугольный треугольник
```
addLine(Vector2D(0, 0), Vector2D(M_PI / 2, 0));
addLine(Vector2D(M_PI / 2, 0), Vector2D(M_PI / 2, M_PI / 2));
addLine(Vector2D(0.0, M_PI / 2), Vector2D(M_PI / 2, M_PI / 2));
```
**Важно:** Легко понять, что ```addLine(Vector2D(0, 0), Vector2D(M_PI, 0));``` не стоит писать, т.к. в этом случае существует бесконечное множество полилиний. Аналогично, и для всех линий, у которых координата одного конца совпадает с соответствующей координатой другого конца, а другая пара координат отличается на угол в M_PI.

Добавляем синюю линию
```
addLine(Vector2D(0, 0), Vector2D(M_PI / 2, 0), QColor::fromRgb(0x0, 0xFF, 0));
```

**Важно:** Возможно, это не легко понять, но абсолютно все точки вида Vector2D(0, azimuth) будут находиться на северном полюсе сферы. Аналогично ```Vector2D(M_PI, azimuth)``` - на южном. Также следует учесть, что линия с нулевой длиной это не точка. Поэтому ```addLine(Vector2D(0, a1), Vector2D(0, a2))``` не будет отрисовываться даже в виде точки. Но ```addPoint(Vector2D(0, a1))``` уже отрисуется без проблем.

Добавляем на сферу точку с *полярным* углом в 30 градусов и *азимутальным* в 180 градусов
```
addPoint(Vector2D(M_PI / 6, M_PI));
```

Удалим со сферы точки с *полярным* углом в 15 градусов и *азимутальным* в 97 градусов
```
removePoints(Vector2D(M_PI / 8, 97 * M_PI / 180));
```

Удалим со сферы точки с *полярным* углом в 45 градусов и *азимутальным* в 67 градусов с погрешностью в 10^(-12) градуса
```
removePoints(Vector2D(M_PI / 4, 67 * M_PI / 180), 1e-12);
```

**Важно:** Т.к. у нас сферическое неограниченное пространство, то на сфере могут быть точки и полилинии с периодическими координатами. Например, точки: ```Vector2D(1, M_PI) <=> Vector2D(1, 3 * M_PI) <=> Vector2D(1, 5 * M_PI)```, но отрисовка будет только одной точки.

## События визуализатора
Можно обрабатывать события добавления или удаления геометрических примитивов. Для этого нужно переопределить соответствующие методы класса Visualization.

Вызывается при добавлении точки
```
virtual void handleAddingPoint(const Vector2D& point);
```

Вызывается при удалении точки
```
virtual void handleRemovingPoint(const Vector2D& point);
```

Вызывается при добавлении линии
```
virtual void handleAddingLine(const Vector2D& start, const Vector2D& end);
```

Вызывается при удалении линии
```
virtual void handleRemovingLine(const Vector2D& start, const Vector2D& end);
```

## Полезные ссылки
http://ru.wikipedia.org/wiki/%D0%A1%D1%84%D0%B5%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%82
